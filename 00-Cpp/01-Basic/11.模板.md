# C++模板

模板就是建立通用的模具，大大提高复用性
模板的特点：

* 模板不可以直接使用，它只是一个框架
* 模板的通用并不是万能的

C++另一种编程思想称为 泛型编程 ，主要利用的技术就是模板

C++提供两种模板机制：

* 函数模板

* 类模板



## 1 函数模板

建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表

### 1.1 语法

> template<typename T>
> 函数声明或定义

每个函数模板都是上面这种结构嗷

解释：

template   ---  声明创建模板
typename ---  表面其后面的符号是一种数据类型，可以用class代替，有人用typename T表示函数模板，用class T表示类模板，还有人二个模板都用class T
T                 ---   通用的数据类型，名称可以替换，通常为大写字母T



### 1.2 函数模板调用

* 自动类型推导（隐式类型转换），数据类型T一致才可以使用

* 显示指定类型，在函数调用的小括号前加上一个<>，里面指定类型



### 1.3 函数模板实例

```c++
//利用模板提供通用的交换函数
template<typename T>
void my_swap(T &a,T &b)
{
	T temp = a;
	a = b;
	b = temp;
}

int main(){
    int a = 10;
	int b = 20;
	char c = 'x';
	
	//1、自动类型推导，必须推导出一致的数据类型T才可以使用
	my_swap(a, b);
	//my_swap(a, c);  报错，两个类型不一致

	//2、显示指定类型，加一个指定的类型
	my_swap<int>(a, b);  //这里只能指定int类型，因为a,b就是Int型，
                         //也不能和c换，不支持将char型和int型的直接赋值运算，1/4个字节
	
	cout << "a = " << a << endl;
	cout << "b = " << b << endl;
    
    system("pause");
	return 0;
}
```

> a = 10
>
> b = 10



如果不能自动推导类型，函数模板必须要确定出T的数据类型才可以使用

```c++
template<typename T>
void func()
{
	cout << "func调用" << endl;
}


int main()
{
	//func();//直接调用会报错，因为他并没有确定出T的数据类型
	func<int>();  //除非显式指定数据类型
    system("pause");
	return 0;
}
```

> func调用



### 1.4 普通函数与函数模板区别

* 普通函数调用时可以发生自动类型转换（隐式类型转换）
* 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
* 如果利用显示指定类型的方式，可以发生类型转换

```c++
int myAdd01(int a,int b)
{
	return a + b;
}

template<typename T>
T myAdd02(T a,T b)
{
	return a + b;
}

int main()
{
	int a = 10;
	int b = 20;
	char c = 'c';

	cout << myAdd01(a, c) << endl;
	//正确，将char类型的'c'隐式转换为int类型  'c' 对应 ASCII码 99
	
	//cout << myAdd02(a, c) << endl;
	//错误，利用自动类型推导，不会发生隐式类型转换，a和c的类型不一致

	cout << myAdd02<int>(a, c) << endl;
	//正确，显示指定类型，告诉模板强制转换为int类型
    
    system("pause");
	return 0;
    
}
```

> 109
>
> 109

**总结：**如果是使用模板，建议使用显示强制转换指定数据类型，因为可以自己确定通用类型T



### 1.5 普通函数与函数模板的调用规则

* 如果函数模板和普通函数都可以实现，优先调用普通函数

* 可以通过空模板参数列表来强制调用函数模板

* 函数模板也可以发生重载

* 如果函数模板可以产生更好的匹配,优先调用函数模板

```c++
void myPrint(int a, int b)
{
	cout << "调用的普通函数" << endl;
}

template<typename T>
void myPrint(T a,T b)
{
	cout << "调用的模板函数" << endl;
}

template<typename T>
void myPrint(T a, T b,T c)
{
	cout << "调用重载的模板" << endl;
}

int main()
{
	int a = 10;
	int b = 20;

	//1. 如果函数模板和普通函数都可以实现，优先调用普通函数
	//注意：如果告诉编译器普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到。就是说只要有普通函数就先调用普通函数，找不到函数体自然报错
	myPrint(a, b);    //输出：调用的普通函数

	//2. 可以通过空模板参数列表来强制调用函数模板
	myPrint<>(a, b);  //输出：调用的模板函数

	//3. 函数模板也可以发生重载
    //这里传入3个参数，编译器会找更符合要求的函数
	int c = 30;
	myPrint(a, b, c); //输出：调用重载的模板

	//4. 如果函数模板可以产生更好的匹配,优先调用函数模板
	//因为编译器认为调用普通函数还要把char转为Int，而模板可以直接推出T是char
	char c1 = 'a';
	char c2 = 'b';
	myPrint(c1, c2); //输出：调用的模板函数
	
    system("pause");
	return 0;
}
```

总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性



### 1.6 函数模板的重载

模板的通用性并不是万能的，在下面代码中提供的赋值操作，如果T的数据类型传入的a和b是一个数组或者自定义的类，就无法实现了

```c++
template<class T>
void f(T a, T b)
{
	a = b;
}
```

C++为了解决这种问题，提供模板的重载，可以为这些特定的类型在原有普通函数模板的基础上提供具体化的模板，语法：

`template<> 函数类型 函数名(参数列表)`

具体化：显示原有函数模板的原型和意思，具体化比常规模板优先调用

```c++
//定义类
class People{
public:
	People(string name, int age)
	{
		this->m_Name = name;
		this->m_Age = age;
	}
	string m_Name;
	int m_Age;
};

//普通函数模板
template<class T>
bool myCompare(T& a, T& b)
{
	if (a == b)
	{
		return true;
	}
	else
	{
		return false;
	}
}

//模板重载
template<> bool myCompare(People& p1, People& p2)
{
	if (p1.m_Name == p2.m_Name && p1.m_Age == p2.m_Age)
	{
		return true;
	}
	else
	{
		return false;
	}
}

int main()
{
	int a = 10;
	int b = 20;
	//内置数据类型可以直接使用通用的函数模板
	bool ret1 = myCompare(a, b);
	if (ret1)
	{
		cout << "a == b " << endl;
	}
	else
	{
		cout << "a != b " << endl;
	}


	People p1("Tom", 10);
	People p2("Tom", 10);
	//自定义数据类型，不会调用普通的函数模板
	//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型
	bool ret2 = myCompare(p1, p2);
	if (ret2)
	{
		cout << "p1 == p2 " << endl;
	}
	else
	{
		cout << "p1 != p2 " << endl;
	}
    
    system("pause");
	return 0;
}
```

> a != b
> p1 == p2



总结：

* 利用具体化的模板，可以解决自定义类型的通用化
* 学习模板并不是为了写模板，而是在STL能够运用系统提供的模板





## 2 类模板

类模板作用：建立一个通用类，类中的成员 数据类型可以不具体制定，用一个**虚拟的类型**来代表。



### 2.1 语法

```c++
template<typename T>
类定义/声明
```

**解释：**

template    ---  声明创建模板

typename  ---  表面其后面的符号是一种数据类型，可以用class代替

T                  ---  通用的数据类型，名称可以替换，通常为大写字母



### 2.2 类模板调用

类模板调用时必须要显示指定类型，在类后面加<>，里面写上具体的类型



### 2.3 类模板实例

```C++
#include<iostream>
#include<string>
using namespace std;

template<class NameType, class AgeType> 
class Person
{
public:
	Person(NameType name, AgeType age)
	{
		this->mName = name;
		this->mAge = age;
	}
	void showPerson()
	{
		cout << "name: " << this->mName << " age: " << this->mAge << endl;
	}
public:
	NameType mName;
	AgeType mAge;
};

int main() {
    
	// 指定NameType 为string类型，AgeType 为 int类型
	Person<string, int>P1("孙悟空", 999);
	P1.showPerson();

	system("pause");
	return 0;
}
```

总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板



### 2.4 类模板与函数模板区别

类模板与函数模板区别主要有两点：

* 类模板没有自动类型推导的使用方式

* 类模板在模板参数列表中可以有默认参数

```c++
#include<iostream>
#include<string>
using namespace std;

template<class NameType, class AgeType=int>  //类模板中的模板参数列表 可以指定默认参数
class Person
{
public:
	Person(NameType name, AgeType age)
	{
		this->mName = name;
		this->mAge = age;
	}
	void showPerson()
	{
		cout << "name: " << this->mName << " age: " << this->mAge << endl;
	}
public:
	NameType mName;
	AgeType mAge;
};

int main() {
    // Person p("孙悟空", 1000); // 错误 类模板使用时候，不可以用自动类型推导
	Person <string ,int>p1("孙悟空", 1000); //必须使用显示指定类型的方式，使用类模板
	p1.showPerson();
    
    Person <string> p2("猪八戒", 999); //类模板已经指定了AgeType为int
	p2.showPerson();
    
    system("pause");
	return 0;
}
```

### 2.5 类模板中成员函数创建时机

类模板中成员函数和普通类中成员函数创建时机是有区别的：

**普通类**:中的成员函数一开始就可以创建

**类模板:**中的成员函数在调用时才创建

```c++
#include<iostream>
#include<string>
using namespace std;

//定义两个普通类
class Person1
{
public:
	void showPerson1()
	{
		cout << "Person1 show" << endl;
	}
};

class Person2
{
public:
	void showPerson2()
	{
		cout << "Person2 show" << endl;
	}
};

//定义类模板
template<class T>
class MyClass
{
public:
	
    T obj;
    
	//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成
    //所以下面两行写完是能够编译成功，因为虽然不知道obj是什么数据类型，但模板调用的时候才生成类模板中成员函数，此时类模板还没调用
    //下面调用的时候他才能判断这个类型能不能调用showPerson1还是showPerson2
	void fun1() { obj.showPerson1(); }
	void fun2() { obj.showPerson2(); }
};

int main() {
    
    MyClass<Person1> m;
    m.fun1();  //这个会成功运行
	//m.fun2();//编译会出错，因为Person1不能去调用showPerson2，也说明了模板调用的时候才生成类模板中成员函数
    
    system("pause");
	return 0;
}



```

### 2.6 类模板对象做函数参数

类模板实例化出的对象是可以作为函数的参数的，其向函数传参的方式有如下三种

1. 指定传入的类型   ---  直接显示对象的数据类型，较常用
2. 参数模板化           ---  将对象中的参数变为模板进行传递
3. 整个类模板化       ---  将这个对象类型 模板化进行传递



```c++
#include<iostream>
#include<string>
using namespace std;

//类模板
template<class NameType, class AgeType = int> 
class Person
{
public:
	Person(NameType name, AgeType age)
	{
		this->mName = name;
		this->mAge = age;
	}
	void showPerson()
	{
		cout << "name: " << this->mName << " age: " << this->mAge << endl;
	}
public:
	NameType mName;
	AgeType mAge;
};


//1、指定传入的类型
void printPerson1(Person<string, int> &p)   //就是在原有的Person &p 中间加入<>指定具体类型
{
	p.showPerson();
}
void test01()
{
	Person <string, int >p("孙悟空", 100);
	printPerson1(p);
}


//2、参数模板化
template <class T1, class T2>
void printPerson2(Person<T1, T2>&p)  //不指定具体类型，而是同样用模板，在调用时实例化对象的时候自动根据对象的类型传入
{
	p.showPerson();
	cout << "T1的类型为： " << typeid(T1).name() << endl;
	cout << "T2的类型为： " << typeid(T2).name() << endl;
}
void test02()
{
	Person <string, int >p("猪八戒", 90);
	printPerson2(p);
}


//3、整个类模板化
template<class T>
void printPerson3(T & p)    //直接将整个类模板化，调用时让编译器自动推导类型
{
	cout << "T的类型为： " << typeid(T).name() << endl;
	p.showPerson();

}
void test03()
{
	Person <string, int >p("唐僧", 30);
	printPerson3(p);
}

int main() {

	test01();
	test02();
	test03();

	system("pause");
	return 0;
}
```

总结：使用比较广泛是第一种：指定传入的类型。可读性更好一些。



### 2.7 类模板与继承

类模板也是类，涉及到继承的问题。有以下几点需要注意：

* 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型，如果不指定，编译器无法给子类分配内存（不知道类型，不知道分配多大内存）
* 如果想灵活指定出父类中T的类型，子类也需变为类模板

```c++
#include<iostream>
#include<string>
using namespace std;

//定义类模板
template<class T>
class Base
{
public:
	T m;
};

//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承
class Son :public Base<int> //必须指定一个类型
{
};
void test01()
{
	Son child1;
    cout << typeid(child1.m).name() << endl;   //int
}


//上面这种指定类型的做法也有一个问题就是T只能是int类型了，如果想灵活指定出父类中T的类型，子类也需变为类模板
template<class T1>
class Son2 :public Base<T1>{};  //不具体指定哪种类型，而是也用模板

void test02()
{
	Son2<int> child2;   //灵活指定类型
    Son2<char> child3;
    cout << typeid(child2.m).name() << endl;   //int
    cout << typeid(child3.m).name() << endl;   //char
}

template<class T1,class T2>
class Son3 :public Base<T2>   //T1是自己要用的模板，T2是继承来自父类的模板
{
public:
    T1 n;
}; 
void test03(){
    Son3<char,int> child4;  //第一个char传给T1，是Son3自己的参数，第二个int传给T2，这是传给父类的
    cout << typeid(child4.n).name() << endl;   //char
    cout << typeid(child4.m).name() << endl;   //int
}
```



### 2.8 类模板成员函数类外实现

类模板也是类，类中自然可以定义成员函数，一般成员函数都采用类外实现，这样使得类的结构更加清晰

类外实现成员函数的格式其实就是加一个<>填入模板参数

```c++
#include<iostream>
#include<string>
using namespace std;

//类模板
template<class T1, class T2>
class Person {
public:
	//成员函数类内声明
	Person(T1 name, T2 age);  //构造函数
	void showPerson();        //成员函数

public:
	T1 m_Name;
	T2 m_Age;
};

//构造函数的类外实现
template<class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age)   //原本应该是Person::Person(T1 name, T2 age)，在两个冒号前加上<>即可
{
	this->m_Name = name;
	this->m_Age = age;
}

//成员函数的类外实现
template<class T1, class T2>
Person<T1, T2>::showPerson(){
    cout << "姓名: " << this->m_Name << " 年龄:" << this->m_Age << endl;
}

int main() {
	erson<string, int> p("Tom", 20);
	p.showPerson();

	system("pause");
	return 0;
}
```



### 2.9 类模板分文件编写

**问题：**

日常的程序编写过程中，类的定义一般放在头文件，类的具体内容放在源文件，但由于类模板具有特殊性，类模板中成员函数创建时机是在调用阶段，这就导致分文件编写时链接不到，只包含头文件是会编译出错的

**解决：**

* 解决方式1：直接包含.cpp源文件
* 解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制，app, bpp均可，但一般用hpp



示例：person.hpp中代码：

```c++
#pragma once
#include <iostream>
using namespace std;
#include <string>

template<class T1, class T2>
class Person {
public:
	Person(T1 name, T2 age);
	void showPerson();
public:
	T1 m_Name;
	T2 m_Age;
};

//构造函数 类外实现
template<class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age) {
	this->m_Name = name;
	this->m_Age = age;
}

//成员函数 类外实现
template<class T1, class T2>
void Person<T1, T2>::showPerson() {
	cout << "姓名: " << this->m_Name << " 年龄:" << this->m_Age << endl;
}
```

main.cpp或者其他cpp文件中代码

```c++
#include<iostream>
using namespace std;

//#include "person.h"
#include "person.cpp" //解决方式1，包含cpp源文件

//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp
#include "person.hpp"

int main() {
	Person<string, int> p("Tom", 10);
	p.showPerson();
	ystem("pause");
	return 0;
}
```



### 2.10 类模板与友元

前面知道，全局函数想要访问类中的私有成员，是需要使用友元的。也需要再次提醒的是，尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。

方法一：全局函数类内实现 - 直接在类模板内声明友元即可，比较简单，更推荐使用

```c++
#include<iostream>
#include <string>
using namespace std;

template<class T1, class T2>
class Person
{
	//全局函数配合友元,直接在类内实现
	friend void printPerson(Person<T1, T2> & p){
		cout << "姓名： " << p.m_Name << " 年龄：" << p.m_Age << endl;
	}
    
public:
	Person(T1 name, T2 age){
		this->m_Name = name;
		this->m_Age = age;
	}
    
private:
	T1 m_Name;
	T2 m_Age;
};

int main() {
	Person<string, int> p("Tom", 10);
	printPerson(p);  //需要再次提醒，printPerson()并不是成员函数，这里并不是使用p.showPerson()的格式
	system("pause");
	return 0;
}
```

方法二：全局函数类外实现 - 需要提前让编译器知道全局函数的存在

```c++
#include<iostream>
#include <string>
using namespace std;

//类外实现需要注意的是，需要先做函数模板声明，下方在做函数模板定义，在做友元，这个顺序不能错，需要
template<class T1, class T2> 
class Person;

template<class T1, class T2>
void printPerson2(Person<T1, T2> & p)
{
	cout << "类外实现 ---- 姓名： " << p.m_Name << " 年龄：" << p.m_Age << endl;
}

template<class T1, class T2>
class Person
{
	////全局函数配合友元  类外实现
	friend void printPerson2<>(Person<T1, T2> & p);   //上面声明的printPerson2是一个函数模板，这里再声明的时候需要加上<>
    
public:
	Person(T1 name, T2 age){
		this->m_Name = name;
		this->m_Age = age;
	}
private:
	T1 m_Name;
	T2 m_Age;
};

int main() {
	Person<string, int> p("Tom", 10);
	printPerson2(p);  //需要再次提醒，printPerson2()并不是成员函数，这里并不是使用p.showPerson2()的格式
	system("pause");
	return 0;
}
```



### 2.11  类模板综合案例

案例描述:  实现一个通用的数组类，要求如下：



* 可以对内置数据类型以及自定义数据类型的数据进行存储
* 将数组中的数据存储到堆区
* 构造函数中可以传入数组的容量
* 提供对应的拷贝构造函数以及operator=防止浅拷贝问题
* 提供尾插法和尾删法对数组中的数据进行增加和删除
* 可以通过下标的方式访问数组中的元素
* 可以获取数组中当前元素个数和数组的容量



**示例：**

myArray.hpp中代码

```c++
#pragma once
#include <iostream>
using namespace std;

template<class T>
class MyArray
{
public:
    
	//构造函数
	MyArray(int capacity)
	{
		this->m_Capacity = capacity;
		this->m_Size = 0;
		pAddress = new T[this->m_Capacity];
	}

	//拷贝构造
	MyArray(const MyArray & arr)
	{
		this->m_Capacity = arr.m_Capacity;
		this->m_Size = arr.m_Size;
		this->pAddress = new T[this->m_Capacity];
		for (int i = 0; i < this->m_Size; i++)
		{
			//如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，
			// 普通类型可以直接= 但是指针类型需要深拷贝
			this->pAddress[i] = arr.pAddress[i];
		}
	}

	//重载= 操作符  防止浅拷贝问题
	MyArray& operator=(const MyArray& myarray) {

		if (this->pAddress != NULL) {
			delete[] this->pAddress;
			this->m_Capacity = 0;
			this->m_Size = 0;
		}

		this->m_Capacity = myarray.m_Capacity;
		this->m_Size = myarray.m_Size;
		this->pAddress = new T[this->m_Capacity];
		for (int i = 0; i < this->m_Size; i++) {
			this->pAddress[i] = myarray[i];
		}
		return *this;
	}

	//重载[] 操作符  arr[0]
	T& operator [](int index)
	{
		return this->pAddress[index]; //不考虑越界，用户自己去处理
	}

	//尾插法
	void Push_back(const T & val)
	{
		if (this->m_Capacity == this->m_Size)
		{
			return;
		}
		this->pAddress[this->m_Size] = val;
		this->m_Size++;
	}

	//尾删法
	void Pop_back()
	{
		if (this->m_Size == 0)
		{
			return;
		}
		this->m_Size--;
	}

	//获取数组容量
	int getCapacity()
	{
		return this->m_Capacity;
	}

	//获取数组大小
	int	getSize()
	{
		return this->m_Size;
	}


	//析构
	~MyArray()
	{
		if (this->pAddress != NULL)
		{
			delete[] this->pAddress;
			this->pAddress = NULL;
			this->m_Capacity = 0;
			this->m_Size = 0;
		}
	}

private:
	T * pAddress;  //指向一个堆空间，这个空间存储真正的数据
	int m_Capacity; //容量
	int m_Size;   // 大小
};
```



test.cpp中

```c++
#include "myArray.hpp"
#include <string>

void printIntArray(MyArray<int>& arr) {
	for (int i = 0; i < arr.getSize(); i++) {
		cout << arr[i] << " ";
	}
	cout << endl;
}

//测试内置数据类型
void test01()
{
	MyArray<int> array1(10);
	for (int i = 0; i < 10; i++)
	{
		array1.Push_back(i);
	}
	cout << "array1打印输出：" << endl;
	printIntArray(array1);
	cout << "array1的大小：" << array1.getSize() << endl;
	cout << "array1的容量：" << array1.getCapacity() << endl;

	cout << "--------------------------" << endl;

	MyArray<int> array2(array1);
	array2.Pop_back();
	cout << "array2打印输出：" << endl;
	printIntArray(array2);
	cout << "array2的大小：" << array2.getSize() << endl;
	cout << "array2的容量：" << array2.getCapacity() << endl;
}


class Person {
public:
	Person() {} 
		Person(string name, int age) {
		this->m_Name = name;
		this->m_Age = age;
	}
public:
	string m_Name;
	int m_Age;
};

void printPersonArray(MyArray<Person>& personArr)
{
	for (int i = 0; i < personArr.getSize(); i++) {
		cout << "姓名：" << personArr[i].m_Name << " 年龄： " << personArr[i].m_Age << endl;
	}

}

//测试自定义数据类型
void test02()
{
	//创建数组
	MyArray<Person> pArray(10);
	Person p1("孙悟空", 30);
	Person p2("韩信", 20);
	Person p3("妲己", 18);
	Person p4("王昭君", 15);
	Person p5("赵云", 24);

	//插入数据
	pArray.Push_back(p1);
	pArray.Push_back(p2);
	pArray.Push_back(p3);
	pArray.Push_back(p4);
	pArray.Push_back(p5);

	printPersonArray(pArray);

	cout << "pArray的大小：" << pArray.getSize() << endl;
	cout << "pArray的容量：" << pArray.getCapacity() << endl;

}

int main() {
    
	//test01();
	test02();
    
	system("pause");
	return 0;
}
```



