参考资料：

* 黑马 JVM 视频
* 《深入理解Java虚拟机》

## 一、什么是JVM

### 定义

Java Virtual Machine，JAVA程序的**运行环境**（JAVA二进制字节码的运行环境）

### 好处

- 一次编写，到处运行
- 自动内存管理，垃圾回收机制
- 数组下标越界检查
- JVM内部使用虚方法调用的机制实现了多态

### 比较

JVM JRE JDK的区别

[![T3YnbR.png](https://s4.ax1x.com/2021/12/22/T3YnbR.png)](https://imgtu.com/i/T3YnbR)



## 二、内存结构

整体架构

[![T3YKV1.png](https://s4.ax1x.com/2021/12/22/T3YKV1.png)](https://imgtu.com/i/T3YKV1)

### 1、程序计数器

#### 作用

用于保存JVM中下一条所要执行的指令的地址

#### 特点

- 线程私有
    - CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码
    - 程序计数器是**每个线程**所**私有**的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令
- 不会存在内存溢出



### 2、栈

#### 定义

- 每个**线程**运行需要的内存空间，称为**虚拟机栈**
- 每个栈由多个**栈帧**(Frame)组成，对应着每次调用方法时所占用的内存
- 每个线程只能有**一个活动栈帧**，对应着**当前正在执行的方法**

```java
public class Main {
	public static void main(String[] args) {
		method1();
	}

	private static void method1() {
		method2(1, 2);
	}

	private static int method2(int a, int b) {
		int c = a + b;
		return c;
	}
}
```

在控制台中可以看到，主类中的方法在进入虚拟机栈的时候，符合栈的特点

[![T3Ymr9.png](https://s4.ax1x.com/2021/12/22/T3Ymr9.png)](https://imgtu.com/i/T3Ymr9)

#### 问题辨析

- 垃圾回收是否涉及栈内存？
    - **不需要**。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。
- 栈内存的分配越大越好吗？
    - 不是。栈内存越大，虽然可以支持更多的递归调用，但因为**物理内存是一定的**，导致可执行的总线程数就会越少。
- 方法内的局部变量是否是线程安全的？
    - 如果方法内**局部变量没有逃离方法的作用范围**，则是**线程安全**的
    - 如果**局部变量引用了对象**，并**逃离了方法的作用范围**，则需要考虑线程安全问题。例如形参、返回值等，其他线程能够访问到该线程的局部变量，则容易引起线程安全问题



#### 内存溢出

**Java.lang.stackOverflowError** 栈内存溢出

**发生原因**

- 虚拟机栈中，**栈帧过多**（无限递归）

​	   也可能是第三方库问题导致无限递归，比如员工类中有部门信息，部门类中有员工，导致相互引用无限递归（详见视频P13）

- 每个栈帧**所占用过大**  较少见

#### 线程运行诊断

CPU占用过高

- Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程
    - **top**命令，查看是哪个**进程**占用CPU过高
    - **ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号** 通过ps命令进一步查看是哪个线程占用CPU过高
    - **jstack 进程id** 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来**对比定位**，注意jstack查找出的线程id是**16进制的**，**需要转换**



### 3、本地方法栈

一些带有**native关键字**的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法



### 4、堆

#### 定义

通过new关键字**创建的对象**都会被放在堆内存

#### 特点

- **所有线程共享**，堆内存中的对象都需要**考虑线程安全问题**
- 有垃圾回收机制（new的对象没有指向引用了之后会被垃圾回收）

#### 堆内存溢出

**java.lang.OutofMemoryError** ：java heap space. 堆内存溢出

#### 堆内存诊断

**jps**：查看当前系统中有哪些 java 进程

**jmap**：查看堆内存占用情况，  jmap - heap 进程id

**jconsole**：图形界面的，多功能的监测工具，可以连续监测

**jvirsalvm**：同上，性能更强大























